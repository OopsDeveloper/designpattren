*브릿지 패턴
'추상화'와 '구현'을 분리해서 이 둘을 독립적으로 다양화할 수 있도록 하는 패턴
추상화 부분과 구현 부분이 각각 추상 클래스와 인터페이스로 따로 작성 되어있다
그리고 추상화 부분이 구현 부분을 참조함에 의한 '다리'가 놓여져 있다.
하나의 과정을 세분화될 수 있는 두 부분으로 나눌 수 있다.

TV와 리모컨을 예시로 든다면
이 두개 모두 전원 버튼과 볼륨 조절 버튼이 있다
TV의 버튼들을 누르면 TV 스스로가 해당 기능을 수행한다
즉 전원을 켜고 끄는 일과 볼륨을 올리고 내리는 일이 '어떻게' 수행되는지가 TV에는 구현이 되어 있다
때문에 여기서 TV는 '구현'에 해당된다
반면 리모컨은 버튼들은 TV에게 해당 명령을 전달하는 것 뿐이다
즉 리모컨은 '무엇을 할 수 있는가'만 정의되어 있다
그래서 이 리모컨은 '추상화'에 해당 된다
TV는 리모컨의 존재를 몰라도 되지만 리모컨은 자기가 어떤 기기를 대상으로 하는지 알아야 한다
그래서 '추상화'의 클래스는 '구현'의 클래스에 의존적이다

*사용하는 경우
1. 멀티 플랫폼 지원
   GUI나 렌더링 시스템에서 다양한 플랫폼(Windows, Linux, macOS 등)에 맞춰 동일한 기능을 제공해야 할 때.
   추상화: UIElement (버튼, 체크박스 등)
   구현부: WindowsRenderer, LinuxRenderer 등 플랫폼별 렌더링 클래스

2. 여러 가지 기능과 구현을 조합해야 할 때
   추상화(기능)와 구현부(상세 구현)를 독립적으로 확장할 수 있어 조합의 수가 폭발적으로 증가하는 상황에서 유리.

3. 기존 코드(레거시 시스템)를 변경하지 않고 새 기능을 추가해야 할 때

4. 런타임에 구현체를 바꿔야 할 때
   로깅 시스템
   애플리케이션에서 로그를 저장하는 시스템이 여러 방식(파일, 콘솔, 원격 서버)에 따라 변경될 수 있음.
   추상화: Logger
   구현부: FileLogger, ConsoleLogger, RemoteLogger

5. 핵심 로직과 구체적 구현이 자주 변경될 때
   알림 시스템
   추상화: Notification (SMS, Email, Push 알림)
   구현부: TextMessageService, EmailService, PushService